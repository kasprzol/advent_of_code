// generated by Claude Haiku 3.5 when asked to convert Python solution to Rust.

use std::collections::HashMap;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;
use regex::Regex;

const MAP_HEIGHT: i32 = 103;
const MAP_WIDTH: i32 = 101;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct Point {
    x: i32,
    y: i32,
}

impl std::ops::Add for Point {
    type Output = Point;

    fn add(self, other: Self) -> Self {
        Point {
            x: (self.x + other.x).rem_euclid(MAP_WIDTH),
            y: (self.y + other.y).rem_euclid(MAP_HEIGHT),
        }
    }
}

#[derive(Debug, Clone, Copy)]
struct Robot {
    p: Point,
    v: Point,
}

impl Robot {
    fn move_robot(&mut self) {
        self.p = self.p + self.v;
    }
}

fn load_input(input_path: &Path) -> Vec<Robot> {
    let input_content = std::fs::read_to_string(input_path)
        .expect("Could not read input file");
    
    let robot_regex = Regex::new(r"p=(-?\d+),(-?\d+) v=(-?\d+),(-?\d+)")
        .expect("Invalid regex");
    
    input_content
        .lines()
        .filter(|line| !line.trim().is_empty() && !line.starts_with('#'))
        .map(|line| {
            let captures = robot_regex.captures(line).expect("Invalid robot line");
            Robot {
                p: Point {
                    x: captures[1].parse().expect("Invalid x pos"),
                    y: captures[2].parse().expect("Invalid y pos"),
                },
                v: Point {
                    x: captures[3].parse().expect("Invalid x velocity"),
                    y: captures[4].parse().expect("Invalid y velocity"),
                },
            }
        })
        .collect()
}

fn print_map(robots: &[Robot], out_file: &mut BufWriter<File>) {
    let mut robot_positions: HashMap<Point, usize> = HashMap::new();
    for r in robots {
        *robot_positions.entry(r.p).or_insert(0) += 1;
    }

    for y in 0..MAP_HEIGHT {
        let mut line = String::new();
        for x in 0..MAP_WIDTH {
            let count = robot_positions.get(&Point { x, y }).cloned().unwrap_or(0);
            line.push_str(&if count > 0 { count.to_string() } else { " ".to_string() });
        }
        writeln!(out_file, "{}", line).expect("Write failed");
    }
    writeln!(out_file).expect("Write failed");
}

fn part2(input_path: &Path) {
    let part1_rounds = 1_000_000;
    let mut robots = load_input(input_path);
    
    let out_path = Path::new("/rust-iter/iterations_dump_rust");
    let out_file = File::create(out_path).expect("Could not create output file");
    let mut out_writer = BufWriter::new(out_file);

    for round in 0..part1_rounds {
        writeln!(out_writer, "\n\n\n\n\nIteration {}", round).expect("Write failed");
        print_map(&robots, &mut out_writer);
        
        for robot in &mut robots {
            robot.move_robot();
        }
    }
}

fn main() {
    let input_path = Path::new("/input.txt");
    part2(input_path);
}

